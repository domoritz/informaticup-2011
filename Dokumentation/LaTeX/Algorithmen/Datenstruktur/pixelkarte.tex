\subsection{Pixelkarte}
\paragraph{L"osungsidee}
Die Pixelkarte ist eine Konvertierung der Welt als Vektorkarte in eine Pixeldarstellung. Sie enth"alt einzelne Stadtteile, deren Begrenzungen keine Vektoren mehr sind, sondern Striche auf einer Pixelkarte. 

Bei der Erzeugung der Pixelkarte wird die Karte automatisch skaliert (approximiert). Wird beispielsweise ein Approximationsfaktor von \(2\) angegeben, so werden s"amlichte vorkommende Koordinaten durch \(2\) geteilt. Die Aufl"osung der Karte wird also effektiv durch den Faktor \(4\) geteilt. Der Approximationsfaktor kann entweder manuell eingegeben werden oder automatisch ermittelt werden. Dadurch kann das Programm auch extreme Eingabedateien mit einer gro"sen Kartenbreite oder -h"ohe verarbeiten. Gro"se Eingabedateien werden einfach heruntergerechnet auf kleinere Eingabedateien. Nat"urlich nimmt dadurch auch die Aufl"osung und damit die Genauigkeit der L"osung ab. Die Geschwindigkeit der Algorithmen nimmt daf"ur zu. Wie genau der Zusammenhang zwischen der Geschwindigkeit der Algorithmen und der Gr"o"se der Karte aussieht, kann den Laufzeitabsch"atzungen der einzelnen Algorithmen entnommen werden.

Die Pixelkarte speichert f"ur die einzelnen Pixel keine Farben, sondern Gewichte. Ein Pixel kann sich in einem bestimmten Stadtteil befinden, dem nach der Gewichtungsfunktion der Attribute ein bestimmter Gewichtswert zugewiesen wurde. Jeder Pixel in einem Stadtteil erh"alt das Gewicht des betreffenden Stadtteils geteilt durch die Anzahl an Pixel im Stadtteil als Wert. Summiert man nun beispielsweise nur die H"alfte der Pixel des Stadtteils auf, erh"alt man nur die halbe Bewertung des Stadtteils.

\paragraph{Programm-Dokumentation}
Die Koordinaten der einzelnen Stadtteile wurden zuvor vom Parser erstellt, dabei wurden einfach die Werte aus der Eingabedatei "ubernommen. Die Methode \texttt{in"-for"-ma"-ti"-cup."-Welt"-funk"-ti"-on."-Approxi"-ma"-ti"-on} skaliert (approximiert) die Karte um einen bestimmten Approximationsfaktor. Dazu werden einfach alle Koordinaten der Polygone aller Stadtteile durch den Approximationsfaktor geteilt. Ebenso wird der Radius der Automaten durch den Approximationsfaktor geteilt. 

Nun beginnt die eigentliche Berechnung der Pixelkarte. Dazu werden Java-interne Funktionen verwendet, da diese einseits sehr schnell und andererseits bei extremen Eingabedaten (z.B. Stadtteilen, die aus keinem Pixel bestehen) nicht anf"allig f"ur Fehler sind\footnote{Diesen Teil hatten wir urspr"unglich komplett selbst geschrieben.}. Die Funktion \texttt{in"-for"-ma"-ti"-cup."-Welt"-funk"-ti"-on."-er"-stelle"-Pix"-el"-kar"-te} erstellt die eigentliche Pixelkarte. Dazu werden die Stadtteile als gef"ullte Polygone auf ein \texttt{Buffered"-Image} geschrieben. Danach werden die einzelnen Pixel aus dem Bild ausgelesen und in ein Array geschrieben, auf das effizienter zugegriffen werden kann. Anf"angliche Probleme gab es, weil das Gewicht durch die Anzahl der Pixel geteilt wird und dadurch Werte enstanden, die kleiner als 1 sind. Das \texttt{Buffered"-Image} unterst"utzt jedoch nur Ganzzahlen. Als L"osung wird ein zweites \texttt{Buffered"-Image} erstellt, das angibt, durch welchen Wert jeder Pixel geteilt werden soll.

\paragraph{Laufzeitabsch"atzung}
Das Skalieren (Approximieren) der Karte h"angt lediglich linear von der Anzahl der Koordinaten ab, die verarbeitet werden sollen. Wie schnell das Zeichnen der Polygone geht, ist uns nicht genau bekannt, da diese Aufgabe von Java-Bibliotheken "ubernommen wird. Das "Ubertragen der einzelnen Pixel-Werte in das Array h"angt linear von der Anzahl der Pixel und damit der Gr"o"se der Karte ab. Die Skalierung beschleunigt diesen Prozess nur um einen konstanten Faktor. 